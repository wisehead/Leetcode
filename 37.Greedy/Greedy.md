# 贪心算法
基本概念
贪心算法是指：在每一步求解的步骤中，它要求“贪婪”的选择最佳操作，并希望通过一系列的最优选择，能够产生一个问题的（全局的）最优解。

贪心算法每一步必须满足一下条件：
1、可行的：即它必须满足问题的约束。
2、局部最优：他是当前步骤中所有可行选择中最佳的局部选择。
3、不可取消：即选择一旦做出，在算法的后面步骤就不可改变了。

例题
## l  求最大子数组之和问题

给定一个整数数组（数组元素有负有正），求其连续子数组之和的最大值。

 
```py
def main():
    s = [12,-4,32,-36,12,6,-6]
    print("定义的数组为：",s)
    s_max, s_sum = 0, 0
    for i in range(len(s)):
        s_sum += s[i]
        if s_sum >= s_max:
            s_max = s_sum # 不断更新迭代s_max的值，尽可能的令其最大
        elif s_sum < 0:
            s_sum = 0

    print("最大子数组和为：",s_max)

if __name__ == "__main__":
	main()
```

 

## l  最少加油次数

一辆汽车加满油后可行驶n公里。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。 对于给定的n和k个加油站位置，编程计算最少加油次数。

 

```py
# 设汽车加满油后可行驶n公里，且旅途中有k个加油站

def greedy():
    n = 100
    k = 5
    d = [50,80,39,60,40,32]
    # 表示加油站之间的距离

    num = 0
    # 表示加油次数

    for i in range(k):
        if d[i] > n:
            print('no solution')
            # 如果距离中得到任何一个数值大于n 则无法计算
            return

    i, s = 0, 0
    # 利用s进行迭代
    while i <= k:
        s += d[i]
        if s >= n:
            # 当局部和大于n时则局部和更新为当前距离
            s = d[i]
            # 贪心意在令每一次加满油之后跑尽可能多的距离
            num += 1
        i += 1
    print(num)

if __name__ == '__main__':
    greedy()
```